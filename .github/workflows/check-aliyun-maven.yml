name: Check Aliyun Maven Dependencies and Plugins

on:
  pull_request_target:
    types: [ opened, synchronize, reopened ]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write

jobs:
  check-dependencies:
    # 只在dependabot的PR上运行
    runs-on: ubuntu-latest

    steps:
      - name: Check if PR is from dependabot
        id: check-author
        run: |
          if [[ "${{ github.event.pull_request.user.login }}" == *"dependabot"* ]]; then
            echo "is_dependabot=true" >> $GITHUB_OUTPUT
          else
            echo "is_dependabot=false" >> $GITHUB_OUTPUT
          fi

      - name: Skip non-dependabot PRs with success
        if: steps.check-author.outputs.is_dependabot == 'false'
        run: exit 0
      - name: Checkout code
        if: steps.check-author.outputs.is_dependabot == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}

      - name: Set up Java
        if: steps.check-author.outputs.is_dependabot == 'true'
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Set up Node.js
        if: steps.check-author.outputs.is_dependabot == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        if: steps.check-author.outputs.is_dependabot == 'true'
        run: |
          npm install xml2js
          npm install @actions/github

      - name: Get build file changes
        if: steps.check-author.outputs.is_dependabot == 'true'
        id: get-changes
        run: |
          # 检测项目类型并获取变更内容
          if [ -f "pom.xml" ]; then
            echo "build_type=maven" >> $GITHUB_OUTPUT
            # PR事件获取当前PR的pom.xml变更
            git diff origin/${{ github.event.pull_request.base.ref }} -- pom.xml > changes.diff || true
          elif [ -f "build.gradle" ]; then
            echo "build_type=gradle" >> $GITHUB_OUTPUT
            git diff origin/${{ github.event.pull_request.base.ref }} -- build.gradle > changes.diff || true
          else
            echo "No supported build file found"
            exit 0
          fi
          echo "changes<<EOF" >> $GITHUB_OUTPUT
          cat changes.diff >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Parse dependencies and plugins
        if: steps.check-author.outputs.is_dependabot == 'true'
        id: parse-deps
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const xml2js = require('xml2js');
            try {
              const buildType = '${{ steps.get-changes.outputs.build_type }}';
              const changes = '${{ steps.get-changes.outputs.changes }}';
              const allComponents = []; // Changed to allComponents to include both deps and plugins

              if (buildType === 'gradle') {
                // Gradle 依赖解析
                // Note: This script currently only handles added dependencies (lines starting with '+')
                // For a more robust solution, you might need to compare the entire build.gradle
                // before and after the PR to identify actual changes.
                const regex = /([+-])\s*(implementation|api|compile|testImplementation|runtimeOnly)\s*['"]([^'"]+)['"]/g;
                let match;

                while ((match = regex.exec(changes)) !== null) {
                  if (match[1] === '+') { // Only consider added dependencies for simplicity
                    const depParts = match[3].split(':');
                    if (depParts.length === 3) {
                      allComponents.push({
                        group: depParts[0],
                        artifact: depParts[1],
                        version: depParts[2],
                        type: 'dependency' // Mark as dependency
                      });
                    }
                  }
                }
              } else if (buildType === 'maven') {
                // Maven 依赖和插件解析
                const pomContent = fs.readFileSync('pom.xml', 'utf-8');
                const parser = new xml2js.Parser({ explicitArray: false });
                const result = await parser.parseStringPromise(pomContent);

                const diffLines = changes.split('\n');
                const changedProperties = {};

                // Extract properties
                const properties = result.project?.properties || {};

                // Identify changed properties from the diff
                const propertyRegex = /^([+-])\s*<([^>]+)>\s*([^<]+)\s*<\/[^>]+>$/; // Updated regex to be more general for properties
                for (const line of diffLines) {
                    const match = line.match(propertyRegex);
                    if (match && match[1] === '+') {
                        const propName = match[2];
                        const propValue = match[3].trim();
                        changedProperties[propName] = propValue;
                    }
                }
                const effectiveProperties = { ...properties, ...changedProperties };

                console.log("=====changedProperties=====");
                console.log(changedProperties);

                // Helper function to resolve versions from properties
                const resolveVersion = (version, effectiveProps) => {
                    if (version && version.startsWith('${') && version.endsWith('}')) {
                        const propName = version.slice(2, -1);
                        return effectiveProps[propName] || version; // Return resolved version or original if not found
                    }
                    return version;
                };

                // Recursive function to extract dependencies
                const extractDeps = (depsContainer, scope) => {
                  if (!depsContainer?.dependency) return;
                  const depList = Array.isArray(depsContainer.dependency) ? depsContainer.dependency : [depsContainer.dependency];

                  depList.forEach(dep => {
                    if (!dep.groupId || !dep.artifactId) return;

                    let version = resolveVersion(dep.version, effectiveProperties);

                    // Only include if the version was directly changed or its property changed
                    if (changedProperties[dep.version?.slice(2,-1)] || (!dep.version || !dep.version.startsWith('${'))) {
                        allComponents.push({
                            group: dep.groupId,
                            artifact: dep.artifactId,
                            version: version,
                            scope: scope || dep.scope || 'compile',
                            type: 'dependency', // Mark as dependency
                            isManaged: scope === 'management'
                        });
                    }
                  });
                };

                // Recursive function to extract plugins
                const extractPlugins = (pluginsContainer, scope) => {
                    if (!pluginsContainer?.plugin) return;
                    const pluginList = Array.isArray(pluginsContainer.plugin) ? pluginsContainer.plugin : [pluginsContainer.plugin];

                    pluginList.forEach(plugin => {
                        if (!plugin.groupId || !plugin.artifactId) return;

                        let version = resolveVersion(plugin.version, effectiveProperties);

                        // Only include if the version was directly changed or its property changed
                        if (changedProperties[plugin.version?.slice(2,-1)] || (!plugin.version || !plugin.version.startsWith('${'))) {
                            allComponents.push({
                                group: plugin.groupId,
                                artifact: plugin.artifactId,
                                version: version,
                                type: 'plugin', // Mark as plugin
                                isManaged: scope === 'pluginManagement'
                            });
                        }
                    });
                };

                // 1. Extract dependencies from dependencyManagement
                if (result.project?.dependencyManagement?.dependencies) {
                    extractDeps(result.project.dependencyManagement.dependencies, 'management');
                }

                // 2. Extract regular dependencies
                if (result.project?.dependencies) {
                    extractDeps(result.project.dependencies);
                }

                // 3. Extract plugins from pluginManagement
                if (result.project?.build?.pluginManagement?.plugins) {
                    extractPlugins(result.project.build.pluginManagement.plugins, 'pluginManagement');
                }

                // 4. Extract regular plugins
                if (result.project?.build?.plugins) {
                    extractPlugins(result.project.build.plugins);
                }

              }

              core.setOutput('components', JSON.stringify(allComponents)); // Output as 'components'
              console.log("=====allComponents.length=====");
              console.log(allComponents.length);
              return allComponents.length;
            } catch (error) {
              core.setFailed(`Failed to parse dependencies and plugins: ${error}`);
            }

      - name: Check Aliyun Maven availability
        if: steps.check-author.outputs.is_dependabot == 'true' && steps.parse-deps.outputs.components != '[]'
        id: check-aliyun
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { execSync } = require('child_process');

            try {
              const components = JSON.parse('${{ steps.parse-deps.outputs.components }}'); // Get 'components'
              const aliMavenUrl = 'https://maven.aliyun.com/repository/public';
              const results = [];
              const errresults = [];

              for (const comp of components) {
                // Skip specific artifacts if needed (e.g., javafxTool- which might not be in public repos)
                if (comp.artifact.startsWith("javafxTool-")) {
                  continue;
                }

                const artifactPath = comp.group.replace(/\./g, '/') + '/' + comp.artifact + '/' + comp.version;
                const pomUrl = `${aliMavenUrl}/${artifactPath}/${comp.artifact}-${comp.version}.pom`;
                console.log(`Checking: ${pomUrl}`);

                try {
                  // Use a timeout for curl to prevent hanging
                  execSync(`curl -m 10 -I -s -o /dev/null -w "%{http_code}" ${pomUrl} | grep 200`);
                  results.push(`✅ [${comp.type === 'plugin' ? '插件' : '依赖'}] ${comp.group}:${comp.artifact}:${comp.version} - 可用`);
                } catch (e) {
                  errresults.push(`❌ [${comp.type === 'plugin' ? '插件' : '依赖'}] ${comp.group}:${comp.artifact}:${comp.version} - 不可用`);
                }
              }

              if (results.length > 0 || errresults.length > 0) { // Ensure comment is made even if all are available
                const { data: comments } = await github.rest.issues.listComments({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                });

                // Find our previously posted comment (by specific identifier)
                const botComment = comments.find(comment =>
                  comment.user.login === 'github-actions[bot]' &&
                  comment.body.startsWith('### 阿里云 Maven 组件检查结果') // Updated comment identifier
                );

                const commentBody = `### 阿里云 Maven 组件检查结果\n\n${errresults.join('\n')}\n\n<details><summary>点击查看可用的组件</summary>${results.join('<br>\n')}<br></details>`;

                if (botComment) {
                  // Update existing comment
                  await github.rest.issues.updateComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      comment_id: botComment.id,
                      body: commentBody
                  });
                } else {
                  // Create new comment
                  github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: context.issue.number,
                      body: commentBody
                  });
                }

                core.setOutput('result', commentBody);
              } else {
                  core.setOutput('result', 'No new dependencies or plugins found to check.');
              }
              return 'Component check completed';
            } catch (error) {
              core.setFailed(`Action failed with error: ${error}`);
            }

      - name: Output result
        if: steps.check-author.outputs.is_dependabot == 'true' && steps.parse-deps.outputs.components != '[]'
        run: echo "${{ steps.check-aliyun.outputs.result }}"

